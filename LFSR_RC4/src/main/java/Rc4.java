import java.security.SecureRandom;

public class Rc4 {
    private int[][] key;
    private int[][] S = new int[256][8];
    int keyLength;
    int firstByte;
    int secondByte;
    static int maximum = 10_000;

    /**
     * Constructor used to randomly generate the 8 bytes containing only 0 and 1.
     */
    public Rc4() {
        this.keyLength = 8;
        this.firstByte = 0;
        this.secondByte = 0;

        SecureRandom rd = new SecureRandom();
        this.key = new int[8][8];
        for (int i = 0; i < 8; i++) {
            for (int j = 0; j < 8; j++) {
                key[i][j] = rd.nextInt(2);
            }
        }
    }

    /**
     * Method used for Key Scheduling Algorithm for turning the random key into an initial permutation of S.
     */
    public void KSA() {
        for(int i = 0; i < S.length; i++) {
            S[i] = toBinary(i);
        }
        int j = 0;
        for(int i = 0; i < 256; i++) {
            int sByte = toDecimal(S[i]);
            int keyByte = toDecimal(key[i % keyLength]);

            j = (j + sByte + keyByte) % 256;  // j = (j + S[i] + key[i mod L]) mod N

            int[] temp = S[i];
            S[i] = S[j];
            S[j] = temp;
        }
    }

    /**
     * Method uses the key from the KSA and generates a pseudo-random output sequence.
     * @return  The generated byte M
     */
    public int[] PRGA() {
        firstByte = (firstByte + 1) % 256;
        secondByte = (secondByte + toDecimal( S[firstByte] )) % 256;

        int[] temp = S[firstByte];
        S[firstByte] = S[secondByte];
        S[secondByte] = temp;

        // M = S[ (S[i] + S[j]) mod N ]
        int M = ( toDecimal(S[firstByte]) + toDecimal(S[secondByte]) ) % 256;
        return S[M];
    }

    /**
     * Method used to convert a decimal number into binary.
     * @param dec  The decimal number
     * @return     The binary number
     */
    public int[] toBinary(int dec) {
        int[] binaryNum = new int[8];
        int numberToConvert = dec;

        for(int i = 7; i >= 0; i--) {
            binaryNum[i] = numberToConvert % 2;
            numberToConvert /= 2;
        }
        return binaryNum;
    }

    /**
     * Method used to convert a binary number into decimal.
     * @param bin   The binary number
     * @return      The decimal number
     */
    public int toDecimal(int[] bin) {
        int decimalNum = 0;
        int power = 1;
        for(int i = 7; i >= 0; i--) {
            decimalNum += (bin[i] * power);
            power *= 2;
        }
        return decimalNum;
    }

    public static void startApp() {
        System.out.println("RC4 Generator...");
        double zeroCounter = 0;
        for(int k = 0; k < maximum; k++) {
            Rc4 rc4 = new Rc4();
            rc4.KSA();
            int[] generatedByte = new int[8];
            int[] secondByte = new int[8];  // second byte to be taken into account

            for (int i = 0; i < 256; i++) {
                generatedByte = rc4.PRGA();
                if (i == 1) {
                    secondByte = generatedByte;
                }
            }
            if(rc4.toDecimal(secondByte) == 0) {
                zeroCounter++;
            }
        }
        System.out.println("The 0 byte was generated " + zeroCounter + " times over " + maximum + " iterations, having the probability of " + (zeroCounter / 10_000) );
        System.out.println(" -> 1/128 = " + (1.0/128));
        System.out.println(" -> 1/256 = " + (1.0/256));
    }

    public static void main(String[] args) {
        long startTime = System.nanoTime();
        startApp();
        long stopTime = System.nanoTime();
        long elapsedTime = stopTime - startTime;
        double elapsedTimeInSecond= (double) elapsedTime / 1_000_000_000;
        System.out.println("Elapsed time: " + elapsedTimeInSecond + " seconds. ");
    }
}
